    0:表示键盘输入(stdin)
    1:表示标准输出(stdout),系统默认是1 
    2:表示错误输出(stderr)


    command >/dev/null 2>&1 &  == command 1>/dev/null 2>&1 &


    1)command:表示shell命令或者为一个可执行程序
    2)>:表示重定向到哪里 
    3)/dev/null:表示Linux的空设备文件 
    4)2:表示标准错误输出
    5)&1:&表示等同于的意思,2>&1,表示2的输出重定向等于于1
    6)&:表示后台执行,即这条指令执行在后台运行



    1>/dev/null:表示标准输出重定向到空设备文件,也就是不输出任何信息到终端,不显示任何信息。
    2>&1:表示标准错误输出重定向等同于标准输出,因为之前标准输出已经重定向到了空设备文件,所以标准错误输出也重定向到空设备文件。


    这条命令的意思就是在后台执行这个程序,并将错误输出2重定向到标准输出1,然后将标准输出1全部放到/dev/null文件,也就是清空.
    所以可以看出" >/dev/null 2>&1 "常用来避免shell命令或者程序等运行中有内容输出。



    command > file 2>file 与 command > file 2>&1 有什么区别呢?

    command > file 2>file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command > file 2>file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道.
    而command >file 2>&1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容.
    从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会用command > file 2>&1 这样的写法.



    2>&1 >/dev/null 

    命令行的重定向什么的, 是在执行命令之前就准备好了的. 解释顺序从左至右依次进行, 2&>1 ,而1是屏幕, 所以标准错误重定向到屏幕, 再而 1>/dev/null , 即标准输出重定向到 /dev/null, 上述2>&1 >/dev/null  并不是什么同一时刻要么产生标准输出要么产生标准错误. 而是两个不同的东西.

    以以下变量的方式做个解释，就很明显了，这两种方式是不同的，前者就像：

    a=1

    b=a



    而后者就像：

    b=a

    a=1


    &>/dev/null

    // 这个就是，不管是啥文件描述符，通通重定向到/dev/null
